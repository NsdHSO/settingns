#!/bin/sh

# Emoji mapping - same emoji mapping for both uppercase and lowercase types
EMOJI_MAPPER() {
    local type_lower=$(echo "$1" | tr '[:upper:]' '[:lower:]')
    case $type_lower in
        feat*) echo "🎸" ;;
        fix*) echo "🛠️" ;;
        docs*) echo "📝" ;;
        style*) echo "🎨" ;;
        refactor*|r) echo "👷" ;;
        test*) echo "🐳" ;;
        chore*) echo "🌻" ;;
        perf*) echo "🚀" ;;
        revert*) echo "⏪" ;;
        *) echo "" ;;
    esac
}

# Process commit message
COMMIT_MSG_FILE=$1
COMMIT_MSG=$(cat "$COMMIT_MSG_FILE")

# Extract first line
FIRST_LINE=$(echo "$COMMIT_MSG" | head -n 1)

# Debug output to a log file
LOG_FILE="/tmp/commit-hook-debug.log"
echo "Original message: $FIRST_LINE" > "$LOG_FILE"

# Check if the commit message follows the pattern "type: message" or similar
if echo "$FIRST_LINE" | grep -q "^[A-Za-z]\+:[[:space:]]*"; then
    # Extract type before the colon (preserving case)
    COMMIT_TYPE=$(echo "$FIRST_LINE" | sed -E 's/^([A-Za-z]+):.*/\1/')
    
    # Extract remaining message after the colon
    MESSAGE_PART=$(echo "$FIRST_LINE" | sed -E 's/^[A-Za-z]+:[[:space:]]*(.*)/\1/')
    
    # Get matching emoji based on commit type
    EMOJI=$(EMOJI_MAPPER "$COMMIT_TYPE")
    
    # Log debugging info
    echo "Type: $COMMIT_TYPE" >> "$LOG_FILE"
    echo "Message: $MESSAGE_PART" >> "$LOG_FILE"
    echo "Emoji: $EMOJI" >> "$LOG_FILE"
    
    # Special handling for uppercase "Refactor" - add "with tests"
    if [ "$COMMIT_TYPE" = "Refactor" ]; then
        # Extract any ticket reference from the end of the message
        TICKET_REF=""
        if echo "$MESSAGE_PART" | grep -q "\[[A-Za-z0-9-]\+\]$"; then
            TICKET_REF=$(echo "$MESSAGE_PART" | grep -o "\[[A-Za-z0-9-]\+\]$")
            MESSAGE_WITHOUT_TICKET=$(echo "$MESSAGE_PART" | sed "s/\[[A-Za-z0-9-]\+\]$//")
            # Add "with tests" before the ticket reference
            NEW_MESSAGE_PART="$MESSAGE_WITHOUT_TICKET with tests $TICKET_REF"
        else
            # No ticket reference, just add "with tests"
            NEW_MESSAGE_PART="$MESSAGE_PART with tests"
        fi
        MESSAGE_PART="$NEW_MESSAGE_PART"
    fi
    
    # Only process if an emoji was found
    if [ -n "$EMOJI" ]; then
        # Replace the first line with emoji after the colon
        NEW_FIRST_LINE="$COMMIT_TYPE: $EMOJI $MESSAGE_PART"
        REMAINING_LINES=$(echo "$COMMIT_MSG" | tail -n +2)
        
        echo "New first line: $NEW_FIRST_LINE" >> "$LOG_FILE"
        
        if [ -n "$REMAINING_LINES" ]; then
            # Multiple lines in commit message
            printf "%s\n%s\n" "$NEW_FIRST_LINE" "$REMAINING_LINES" > "$COMMIT_MSG_FILE"
        else
            # Single line commit message
            echo "$NEW_FIRST_LINE" > "$COMMIT_MSG_FILE"
        fi
    fi
fi

#!/bin/sh

# Emoji mapping
EMOJI_MAPPER() {
    local type=$(echo "$1" | tr '[:upper:]' '[:lower:]')
    case $type in
        feat*) echo "🎸" ;;
        fix*) echo "🛠️" ;;
        docs*) echo "📝" ;;
        style*) echo "🎨" ;;
        refactor*|r) echo "👷" ;;
        test*) echo "🐳" ;;
        chore*) echo "🌻" ;;
        perf*) echo "🚀" ;;
        revert*) echo "⏪" ;;
        *) echo "" ;;
    esac
}

# Normalize commit type (lowercase to proper case)
NORMALIZE_TYPE() {
    local type="$1"
    local lowercase=$(echo "$type" | tr '[:upper:]' '[:lower:]')
    
    case $lowercase in
        feat*) echo "feat" ;;
        fix*) echo "fix" ;;
        docs*) echo "docs" ;;
        style*) echo "style" ;;
        refactor*|r) echo "refactor" ;;
        test*) echo "test" ;;
        chore*) echo "chore" ;;
        perf*) echo "perf" ;;
        revert*) echo "revert" ;;
        *) echo "$type" ;;
    esac
}

# Process commit message
COMMIT_MSG_FILE=$1
COMMIT_MSG=$(cat "$COMMIT_MSG_FILE")

# Extract commit type from first line
FIRST_LINE=$(echo "$COMMIT_MSG" | head -n 1)

# Check if the commit message follows the pattern "type: message" or similar
if echo "$FIRST_LINE" | grep -q "^[A-Za-z]\+:\s*"; then
    # Extract type before the colon
    COMMIT_TYPE=$(echo "$FIRST_LINE" | cut -d ':' -f 1)
    
    # Extract remaining message after the colon (trim leading whitespace)
    MESSAGE_PART=$(echo "$FIRST_LINE" | cut -d ':' -f 2- | sed 's/^[[:space:]]*//')
    
    # Get matching emoji based on (lowercase) commit type
    EMOJI=$(EMOJI_MAPPER "$COMMIT_TYPE")
    
    # Normalize the commit type
    NORMALIZED_TYPE=$(NORMALIZE_TYPE "$COMMIT_TYPE")
    
    # Only process if an emoji was found
    if [ -n "$EMOJI" ]; then
        # Replace the first line while preserving ticket references
        # Make sure there's a space after the colon and before the emoji
        NEW_FIRST_LINE="$NORMALIZED_TYPE: $EMOJI$MESSAGE_PART"
        REMAINING_LINES=$(echo "$COMMIT_MSG" | tail -n +2)
        
        if [ -n "$REMAINING_LINES" ]; then
            # Multiple lines in commit message
            printf "%s\n%s\n" "$NEW_FIRST_LINE" "$REMAINING_LINES" > "$COMMIT_MSG_FILE"
        else
            # Single line commit message
            echo "$NEW_FIRST_LINE" > "$COMMIT_MSG_FILE"
        fi
    fi
fi